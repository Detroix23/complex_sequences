//! # Complex sequences.
//! src/main.rs (Lesson 1 Version)
//!
//! **(AI) - Code generated by Gemini CLI.**
//! This file demonstrates basic ImGui interactivity, state management via closures,
//! and common widgets for a fractal settings panel.

mod support;

use imgui::*;

fn main() {
    // -------------------------------------------------------------------------
    // 1. APPLICATION STATE
    // -------------------------------------------------------------------------
    // These variables live as long as the application runs.
    // We define them here, before passing them into the UI closure.
    
    // Selecting the type of fractal (0 = Mandelbrot, 1 = Julia, etc.)
    let mut fractal_type = 0;
    
    // Simulation parameters
    let mut iterations: i32 = 100;
    let mut zoom: f32 = 1.0;
    let mut offset_x: f32 = 0.0;
    let mut offset_y: f32 = 0.0;
    
    // Visual parameters
    let mut color_base: [f32; 3] = [0.2, 0.5, 0.8]; // RGB
    let mut show_grid = true;

    // -------------------------------------------------------------------------
    // 2. UI SETUP
    // -------------------------------------------------------------------------
    let system = support::init_with_startup(
        "Complex Sequences - Settings Lab",
        |_, _, _| {
            // This startup closure runs once. 
            // We could load textures or configure styles here.
            println!("System initialized.");
        },
        // This is the "run_ui" closure. It is called EVERY FRAME.
        // The 'move' keyword transfers ownership of our state variables (zoom, etc.)
        // into this closure so they persist across frames.
        move |_, ui| {
            // -----------------------------------------------------------------
            // 3. WINDOW DEFINITION
            // -----------------------------------------------------------------
            // We create a window named "Fractal Settings".
            ui.window("Fractal Settings")
                .size([300.0, 500.0], Condition::FirstUseEver)
                .position([10.0, 10.0], Condition::FirstUseEver)
                .build(|| {
                    
                    ui.text_wrapped("Adjust the parameters below to control the simulation.");
                    ui.separator();

                    // ---------------------------------------------------------
                    // 4. WIDGETS & LOGIC
                    // ---------------------------------------------------------
                    
                    // SECTION: Fractal Selection
                    ui.text("Fractal Type:");
                    // Radio buttons act like distinct checks.
                    ui.radio_button("Mandelbrot", &mut fractal_type, 0);
                    ui.same_line(); // Put the next widget on the same line
                    ui.radio_button("Julia", &mut fractal_type, 1);
                    ui.same_line();
                    ui.radio_button("Newton", &mut fractal_type, 2);
                    
                    ui.separator();

                    // SECTION: Simulation Params
                    ui.text("Simulation:");
                    
                    // Slider for Integers
                    // build() finalizes the widget.
                    ui.slider("Iterations", 1, 1000, &mut iterations)
                        .build();

                    // Slider for Floats
                    ui.slider("Zoom", 0.1, 100.0, &mut zoom)
                        .flags(SliderFlags::LOGARITHMIC) // Logarithmic scale feels better for zoom
                        .build();
                        
                    // Drag scalars are infinite sliders (click and drag mouse)
                    ui.drag("X Offset", &mut offset_x)
                        .speed(0.01 * zoom) // Adapting speed to zoom level is a nice touch
                        .build();
                        
                    ui.drag("Y Offset", &mut offset_y)
                        .speed(0.01 * zoom)
                        .build();

                    ui.separator();

                    // SECTION: Visuals
                    ui.text("Visuals:");
                    
                    // Color Picker
                    ColorEdit::new("Base Color", &mut color_base)
                        .picker_mode(ColorPickerMode::Wheel)
                        .build(ui);

                    // Checkbox
                    ui.checkbox("Show Grid Overlay", &mut show_grid);

                    ui.separator();

                    // SECTION: Actions
                    // Button returns 'true' only on the frame it is clicked.
                    if ui.button("Reset Settings") {
                        zoom = 1.0;
                        offset_x = 0.0;
                        offset_y = 0.0;
                        iterations = 100;
                        println!("Settings reset!");
                    }
                });

            // -----------------------------------------------------------------
            // 5. DEBUG / DEMO DISPLAY
            // -----------------------------------------------------------------
            // Let's show a second simple window demonstrating the values updating.
            ui.window("Debug Info")
                .size([200.0, 150.0], Condition::FirstUseEver)
                .position([320.0, 10.0], Condition::FirstUseEver)
                .build(|| {
                    ui.text(format!("Current Zoom: {:.4}", zoom));
                    ui.text(format!("Position: ({:.2}, {:.2})", offset_x, offset_y));
                    ui.text(format!("Color: {:?}", color_base));
                    
                    if show_grid {
                         ui.text_colored([0.0, 1.0, 0.0, 1.0], "Grid is ACTIVE");
                    } else {
                         ui.text_colored([1.0, 0.0, 0.0, 1.0], "Grid is HIDDEN");
                    }
                });
        },
    );
}
